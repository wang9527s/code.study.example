

### qml语法

QML是一种描述用户界面的声明式语言。它将用户界面分解成一些更小的元素，这些元素能够结合成一个组件。QML语言描述了用户界面元素的形状和行为。

从QML元素的层次结构来理解是最简单的学习方式。子元素从父元素上继承了坐标系统，它的x,y坐标总是相对应于它的父元素坐标系统。

+ 有如下注意点：

  - 每一个QML文件都需要一个根元素，就像HTML一样。
  - 一个元素使用它的类型声明，然后使用{}进行包含。
  - 元素拥有属性，他们按照name:value的格式来赋值。 
  - 任何在QML文档中的元素都可以使用它们的id进行访问（id是一个任意的标识符）。
  - 元素可以嵌套，这意味着一个父元素可以拥有多个子元素。子元素可以通过访问parent关键字来访问它们的父元素。

你会经常使用id或者关键字parent来访问你的父对象。有一个比较好的方法是命名你的根元素对象id为root（id:root）

+ 脚本直接运行（qml.exe）

```bash
// 直接运行
D:\dev\qt-5.15.2\build\bin\qml.exe .\main.qml
```

```$ $QTDIR/bin/qml.exe main.qml```可以直接运行程序。


#### 属性

```js
Text {
    // 一个id在一个QML文档中是唯一的，并且不能被设置为其它值，也无法被查询（它的行为更像C++世界里的指针）。
    id: thisLabel

    // (2) set x- and y-position
    x: 24; y: 16

    // (3) bind height to 2 * width
    height: 2 * width

    // (4) custom property
    // 自定义属性：如果没有初始值将会给定一个系统初始值作为初始值
    // 意如果属性名与已定义的默认属性名不重复，使用default关键字你可以将一个属性定义为默认属性。这在你添加子元素时用得着，如果他们是可视化的元素，子元素会自动的添加默认属性的子类型链表（children property list）。 ？？？
    property int times: 24

    // (5) property alias
    // 转发一个属性或者转发一个属性对象自身到另一个作用域。
    property alias anotherTimes: thisLabel.times

    // (6) set text appended by value
    // text属性依赖于自定义的timers（int整型数据类型）属性。int整型数据会自动的转换为string字符串类型数据。这样的表达方式本身也是另一种属性绑定的例子，文本结果会在times属性每次改变时刷新。 ？？
    text: "Greetings " + times

    // (7) font is a grouped property
    // 一些属性是按组分配的属性。当一个属性需要结构化并且相关的属性需要联系在一起时，我们可以这样使用它。另一个组属性的编码方式是 font{family: "UBuntu"; pixelSize: 24 }。
    font.family: "Ubuntu"
    font.pixelSize: 24

    // (8) KeyNavigation is an attached property
    // 一些属性是元素自身的附加属性。这样做是为了全局的相关元素在应用程序中只出现一次（例如键盘输入）。
    KeyNavigation.tab: otherLabel

    // (9) signal handler for property changes
    // 信号槽
    onHeightChanged: console.log('height:', height)

    // focus is neeed to receive key events
    focus: true

    // change color based on focus value
    color: focus?"red":"black"
}
```

#### 属性绑定

当你对改变属性的策略有冲突时（文本的改变基于一个增值的绑定并且可以被JavaScript赋值清零），类似于这个例子，你最好不要使用绑定属性。你需要使用赋值的方式来改变属性，属性绑定会在赋值操作后被销毁（销毁协议！）。

### 基本元素

#### 基础元素对象

专注于几个基础的可视化元素，例如Item（基础元素对象），Rectangle（矩形框），Text（文本），Image（图像）和MouseArea（鼠标区域）。

Item（基础元素对象）是所有可视化元素的基础对象，所有其它的可视化元素都继承自Item。它自身不会有任何绘制操作，但是定义了所有可视化元素共有的属性：


| Group（分组）|Properties（属性） |
|--- |--- |
| Geometry（几何属性） | x,y,width,height,z（堆叠次序）定义元素之间的重叠顺序。 |
| Layout handling（布局操作） |anchors（锚定），包括left、right、top、bottom、vertical center、horizontal center</br>anchors与margins（间距）一起定义了元素与其它元素之间的位置关系。 |
| Key handlikng（按键操作） | 附加属性key（按键）和keyNavigation（按键定位）属性来控制按键操作，处理输入焦点（focus）可用操作。 |
| Transformation | 缩放（scale）和rotate（旋转）转换，通用的x,y,z属性列表转换（transform），旋转基点设置（transformOrigin）。 |
| Visual（可视化） | 不透明度（opacity）控制透明度，visible（是否可见）控制元素是否显示，clip（裁剪）用来限制元素边界的绘制，smooth（平滑）用来提高渲染质量。 |
|State definition（状态定义）  | states（状态列表属性）提供了元素当前所支持的状态列表，当前属性的改变也可以使用transitions（转变）属性列表来定义状态转变动画。 |

#### Rectangle Element

color支持很多字符串描述[svg-color](https://www.w3.org/TR/css-color-3/#svg-color)

支持border radius、渐变

#### Text Element

```js
Text {
    //省略位置: 文本左边，右边或者中间的
    elide: Text.ElideMiddle
    // 使用style和styleColor属性来配置文字的外框效果，浮雕效果或者凹陷效果
    style: Text.Sunken
    styleColor: '#FF4444'
    // 文字对齐效果
    verticalAlignment: Text.AlignTop
    // 在明确设置了宽度后才生效
    // wrapMode: Text.WordWrap
}
```

text元素背景是透明的

#### Image Element

```js
Image {
    source: "images/logo.png"
    sourceSize.width: 100
    sourceSize.height: 50

    // fillMode 填充模式

    // 是否裁剪Image元素中显示的图像，以限制其在Image元素外部的显示范围。
    clip : true

    // smooth 默认为true
    // fillColor属性指定了Image元素背后的颜色。这在图像透明时特别有用，它可以为透明的区域提供背景颜色。
    // asynchronous属性用于指定是否异步加载图像。设置为true时，图像将在后台异步加载，不会阻塞主线程。

    // tatus属性指示图像的加载状态，可以是Image.Null、Image.Ready、Image.Loading、Image.Error之一
    onStatusChanged
}
```

#### MouseArea Element

```js
Rectangle {
    id: rect1
    x: 12; y: 12
    width: 76; height: 96
    color: "lightsteelblue"
    MouseArea {
        id: area
        // x: -12; y: -12
        width: parent.width
        height: parent.height
        onClicked: rect2.visible = !rect2.visible
    }
}
```

是一个矩形的非可视化元素对象，你可以通过它来捕捉鼠标事件。当用户与可视化端口交互时，mouseArea通常被用来与可视化元素对象一起执行命令。

这是QtQuick中非常重要的概念，输入处理与可视化显示分开。这样你的**交互区域可以比你显示的区域大很多**。

### 组件

不需要import等操作
组件文件名大写

```js
// Button.qml

import QtQuick 2.14

Rectangle {
    id: root
    // export button properties
    property alias text: label22.text
    signal clicked

    width: 116; height: 26
    color: "lightsteelblue"
    border.color: "slategrey"

    Text {
        id: label22
        anchors.centerIn: parent
        text: "Start"
    }
    MouseArea {
        anchors.fill: parent
        onClicked: {
            root.clicked()
        }
    }
}
```

```js
// main.qml
import QtQuick 2.14
import QtQuick.Window 2.14

Window {
    visible: true
    width: 340
    height: 280
    title: qsTr("Hello World 嗯哼")

    Button { // our Button component
        id: button
        x: 12; y: 12
        text: "Start 33"
        onClicked: {
            status.text = "Button clicked!"
        }
    }

    Text { // text changes when button was clicked
        id: status
        x: 12; y: 76
        width: 116; height: 26
        text: "waiting ..."
        horizontalAlignment: Text.AlignHCenter
    }
}
```

### 简单的转换

QML元素对象通常能够被平移，旋转，缩
放。

```js
son_id_1.x = 20

son_id_1.rotation = 0

son_id_1.scale = 1.0
```

### 定位元素（Positioning Element）

Column（列）元素将它的子对象通过顶部对齐的列方式进行排列。spacing属性用来设置每个元素之间的间隔大小。
```js
    Column {
        id: column
        anchors.centerIn: parent
        spacing: 8
        RedSquare { }
        GreenSquare { width: 96 }
        BlueSquare { }
    }
```
Row（行）元素将它的子对象从左到右，或者从右到左依次排列，排列方式取决于layoutDirection属性。
```js
Row{}
```

Grid（栅格）元素通过设置rows（行数）和columns（列数）将子对象排列在一个栅格中。可以只限制行数或者列数。  

```js
BrightSquare {
    id: root
    width: 160
    height: 160

    Grid {
        id: grid
        rows: 2
        columns: 2
        //  anchors.centerIn: parent
        anchors.bottom: parent.bottom
        spacing: 8
        RedSquare { }
        GreenSquare { }
        RedSquare { }
        RedSquare { }
    }
}
```

最后一个定位器是Flow（流）。通过flow（流）属性和layoutDirection（布局方向）属性来控制流的方向。它能够从头到底的横向布局，也可以从左到右或者从右到左进行布局。  
为了让一个流可以工作，必须指定一个宽度或者高度，可以通过属性直接设定，或者通过anchor（锚定）布局设置。

```js
    Grid{
        anchors.fill: parent
        anchors.margins: 8
        spacing: 4
        Repeater {
            // 重复次数
            model: 14
            Rectangle {
                width: 56; height: 56
                property int colorIndex: Math.floor(Math.random()*3)
                color: root.colorArray[colorIndex]
                border.color: Qt.lighter(color)
                Text {
                    anchors.centerIn: parent
                    color: "#f0f0f0"
                    text: "C " + index
                }
            }
        }
    }
```

### 布局元素（Layout Element）

```js
// 元素填充它的父元素
anchors.fill: parent

// 元素左对齐它的父元素
anchors.left: parent.left

// 元素的左边与它父元素的右边对齐(超出父元素区域)
anchors.left: parent.right
```
```js
     GreenSquare {
         BlueSquare {
             id: blue1
             width: 48; height: 24
             y: 8
             // blue1 水平居中
             anchors.horizontalCenter: parent.horizontalCenter
         }
         BlueSquare {
             id: blue2
             width: 72; height: 24
             // blue2 位于blue下方4像素
             anchors.top: blue1.bottom
             anchors.topMargin: 4
             // blue2 水平居中
             anchors.horizontalCenter: blue1.horizontalCenter
             text: '(4)'
         }
     }
```
```js
// 元素在它的父元素中居中
anchors.centerIn: parent

// 水平方向居中对齐父元素并向左侧偏移12像素，垂直方向居中对齐
anchors.horizontalCenter: parent.horizontalCenter
anchors.horizontalCenterOffset: -12
anchors.verticalCenter: parent.verticalCenter
```

```ch04-qmlstart\anchors\AnchorsExample.qml```中的例子。  
我们的方格都打开了拖拽。试着拖放几个方格。  
你可以发现第一个方格无法被拖拽因为它每个边都被固定了，当然第一个方格的父元素能够被拖拽是因为它的父元素没有被固定。  
第二个方格能够在垂直方向上拖拽是因为它只有左边被固定了。  
类似的第三个和第四个方格也只能在垂直方向上拖拽是因为它们都使用水平居中对齐。  
第五个方格使用居中布局，它也无法被移动，第六个方格与第五个方格类似。拖拽一个元素意味着会改变它的x,y坐标。anchoring（锚定）比几何变化（例如x,y坐标变化）更强大是因为锚定线（anchored lines）的限制，我们将在后面讨论动画时看到这些功能的强大。

### 输入元素（Input Element）

####  文本输入（TextInput）

```js
Rectangle {
    width: 200
    height: 80
    color: "linen"

    TextInput {
        id: input1
        x: 8; y: 8
        width: 96; height: 20
        // 焦点
        focus: true
        text: "Text Input 1"

        // KeyNavigation（按键向导）, 点击Tab后，较短切换到 input2
        KeyNavigation.tab: input2
    }

    TextInput {
        id: input2
        x: 8; y: 36
        width: 96; height: 20
        text: "Text Input 2"
        KeyNavigation.tab: input1
    }
}
```

#### 焦点区域（FocusScope）

 如果焦点区域接收到焦点，它将会把焦点传递给最后申请焦点的子元素。
 TODO焦点有哪些流动规则

#### 文本编辑（TextEdit）

#### 按键元素（Key Element）

附加属性key允许你基于某个按键的点击来执行代码。例如使用up，down按键来移动一个方块，left，right按键来旋转一个元素，plus，minus按键来缩放一个元素。

```js
    Keys.onLeftPressed: square.x -= 8
    Keys.onRightPressed: square.x += 8
    Keys.onUpPressed: square.y -= 8
    Keys.onDownPressed: square.y += 8
    Keys.onPressed: {
        switch(event.key) {
            case Qt.Key_Plus:
                square.scale += 0.2
                break;
            case Qt.Key_Minus:
                square.scale -= 0.2
                break;
        }
    }
```

#### 高级用法
